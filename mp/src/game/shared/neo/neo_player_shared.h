#ifndef NEO_PLAYER_SHARED_H
#define NEO_PLAYER_SHARED_H
#ifdef _WIN32
#pragma once
#endif

#include "neo_predicted_viewmodel.h"

#ifdef INCLUDE_WEP_PBK
// Type to use if we need to ensure more than 32 bits in the mask.
#define NEO_WEP_BITS_UNDERLYING_TYPE long long int
#else
// Using plain int if we don't need to ensure >32 bits in the mask.
#define NEO_WEP_BITS_UNDERLYING_TYPE int
#endif

// All of these should be able to stack create even slower speeds (at least in original NT)
#define NEO_SPRINT_MODIFIER 1.6
#define NEO_SLOW_MODIFIER 0.75

#define NEO_BASE_NORM_SPEED 136
#define NEO_BASE_SPRINT_SPEED (NEO_BASE_NORM_SPEED * NEO_SPRINT_MODIFIER)
#define NEO_BASE_WALK_SPEED (NEO_BASE_NORM_SPEED * NEO_SLOW_MODIFIER)
#define NEO_BASE_CROUCH_SPEED (NEO_BASE_NORM_SPEED * NEO_SLOW_MODIFIER)

#define NEO_RECON_SPEED_MODIFIER 1.25
#define NEO_ASSAULT_SPEED_MODIFIER 1.0
#define NEO_SUPPORT_SPEED_MODIFIER 0.75

#define NEO_RECON_NORM_SPEED (NEO_BASE_NORM_SPEED * NEO_RECON_SPEED_MODIFIER)
#define NEO_RECON_SPRINT_SPEED (NEO_BASE_SPRINT_SPEED * NEO_RECON_SPEED_MODIFIER)
#define NEO_RECON_WALK_SPEED (NEO_BASE_WALK_SPEED * NEO_RECON_SPEED_MODIFIER)
#define NEO_RECON_CROUCH_SPEED (NEO_BASE_CROUCH_SPEED * NEO_RECON_SPEED_MODIFIER)

#define NEO_ASSAULT_NORM_SPEED (NEO_BASE_NORM_SPEED * NEO_ASSAULT_SPEED_MODIFIER)
#define NEO_ASSAULT_SPRINT_SPEED (NEO_BASE_SPRINT_SPEED * NEO_ASSAULT_SPEED_MODIFIER)
#define NEO_ASSAULT_WALK_SPEED (NEO_BASE_WALK_SPEED * NEO_ASSAULT_SPEED_MODIFIER)
#define NEO_ASSAULT_CROUCH_SPEED (NEO_BASE_CROUCH_SPEED * NEO_ASSAULT_SPEED_MODIFIER)

#define NEO_SUPPORT_NORM_SPEED (NEO_BASE_NORM_SPEED * NEO_SUPPORT_SPEED_MODIFIER)
#define NEO_SUPPORT_SPRINT_SPEED (NEO_BASE_SPRINT_SPEED * NEO_SUPPORT_SPEED_MODIFIER)
#define NEO_SUPPORT_WALK_SPEED (NEO_BASE_WALK_SPEED * NEO_SUPPORT_SPEED_MODIFIER)
#define NEO_SUPPORT_CROUCH_SPEED (NEO_BASE_CROUCH_SPEED * NEO_SUPPORT_SPEED_MODIFIER)

// Sanity checks for class speeds.
// These values are divided with in some contexts, so should never equal zero.
COMPILE_TIME_ASSERT(NEO_RECON_NORM_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_RECON_SPRINT_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_RECON_WALK_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_RECON_CROUCH_SPEED > 0);

COMPILE_TIME_ASSERT(NEO_ASSAULT_NORM_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_ASSAULT_SPRINT_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_ASSAULT_WALK_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_ASSAULT_CROUCH_SPEED > 0);

COMPILE_TIME_ASSERT(NEO_SUPPORT_NORM_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_SUPPORT_SPRINT_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_SUPPORT_WALK_SPEED > 0);
COMPILE_TIME_ASSERT(NEO_SUPPORT_CROUCH_SPEED > 0);

// Class speeds hierarchy should be: recon > assault > support.
COMPILE_TIME_ASSERT(NEO_RECON_NORM_SPEED > NEO_ASSAULT_NORM_SPEED);
COMPILE_TIME_ASSERT(NEO_ASSAULT_NORM_SPEED > NEO_SUPPORT_NORM_SPEED);

COMPILE_TIME_ASSERT(NEO_RECON_SPRINT_SPEED > NEO_ASSAULT_SPRINT_SPEED);
COMPILE_TIME_ASSERT(NEO_ASSAULT_SPRINT_SPEED > NEO_SUPPORT_SPRINT_SPEED);

COMPILE_TIME_ASSERT(NEO_RECON_WALK_SPEED > NEO_ASSAULT_WALK_SPEED);
COMPILE_TIME_ASSERT(NEO_ASSAULT_WALK_SPEED > NEO_SUPPORT_WALK_SPEED);

COMPILE_TIME_ASSERT(NEO_RECON_CROUCH_SPEED > NEO_ASSAULT_CROUCH_SPEED);
COMPILE_TIME_ASSERT(NEO_ASSAULT_CROUCH_SPEED > NEO_SUPPORT_CROUCH_SPEED);

#define SUPER_JMP_COST 45.0f
#define CLOAK_AUX_COST ((GetClass() == NEO_CLASS_RECON) ? 17.5f : 19.0f)

// Original NT allows chaining superjumps up ramps,
// so leaving this zeroed for enabling movement tricks.
#define SUPER_JMP_DELAY_BETWEEN_JUMPS 0

// NEO Activities
#define ACT_NEO_ATTACK ACT_RANGE_ATTACK1
#define ACT_NEO_RELOAD ACT_RELOAD
#define ACT_NEO_IDLE_STAND ACT_IDLE
#define ACT_NEO_IDLE_CROUCH ACT_CROUCHIDLE
#define ACT_NEO_MOVE_RUN ACT_RUN
#define ACT_NEO_MOVE_WALK ACT_WALK
#define ACT_NEO_MOVE_CROUCH ACT_RUN_CROUCH
#define ACT_NEO_DIE ACT_DIESIMPLE
#define ACT_NEO_HOVER ACT_HOVER
#define ACT_NEO_JUMP ACT_HOP
#define ACT_NEO_SWIM ACT_SWIM

#ifdef GAME_DLL
#define NEO_ACT_TABLE_ENTRY_REQUIRED false
#define NEO_IMPLEMENT_ACTTABLE(CNEOWepClass) acttable_t CNEOWepClass::m_acttable[] = {\
{ ACT_NEO_ATTACK, ACT_NEO_ATTACK, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_RELOAD, ACT_NEO_RELOAD, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_IDLE_STAND, ACT_NEO_IDLE_STAND, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_IDLE_STAND, ACT_NEO_IDLE_STAND, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_IDLE_CROUCH, ACT_NEO_IDLE_CROUCH, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_MOVE_RUN, ACT_NEO_MOVE_RUN, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_MOVE_WALK, ACT_NEO_MOVE_WALK, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_MOVE_CROUCH, ACT_NEO_MOVE_CROUCH, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_DIE, ACT_NEO_DIE, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_HOVER, ACT_NEO_HOVER, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_JUMP, ACT_NEO_JUMP, NEO_ACT_TABLE_ENTRY_REQUIRED },\
{ ACT_NEO_SWIM, ACT_NEO_SWIM, NEO_ACT_TABLE_ENTRY_REQUIRED },\
};IMPLEMENT_ACTTABLE(CNEOWepClass);
#else
#define NEO_IMPLEMENT_ACTTABLE(CNEOWepClass)
#endif

#define NEO_RECON_EYE_HEIGHT_STANDING 57.0
#define NEO_RECON_EYE_HEIGHT_DUCKING 43.0
#define NEO_ASSAULT_EYE_HEIGHT_STANDING 58.0
#define NEO_ASSAULT_EYE_HEIGHT_DUCKING 44.0
#define NEO_SUPPORT_EYE_HEIGHT_STANDING 60.0
#define NEO_SUPPORT_EYE_HEIGHT_DUCKING 47.0

#define HL2DM_DEFAULT_PLAYERMODEL_HEIGHT 74.0
#define NEO_RECON_PLAYERMODEL_HEIGHT 66.0
#define NEO_ASSAULT_PLAYERMODEL_HEIGHT 67.0
#define NEO_SUPPORT_PLAYERMODEL_HEIGHT 72.0

#define HL2DM_DEFAULT_PLAYERMODEL_DUCK_HEIGHT 36.0
#define NEO_RECON_PLAYERMODEL_DUCK_HEIGHT 48.0
#define NEO_ASSAULT_PLAYERMODEL_DUCK_HEIGHT 50.0
#define NEO_SUPPORT_PLAYERMODEL_DUCK_HEIGHT 61.0

// "Magic number" for scaling the hull ratios below to make them match original NT.
// It makes the hull clearance slightly larger than the actual models (as is the
// case with the original), but ensures that reachability of various places
// inside NT levels remains the same. This specific value was found by binary
// searching until the hulls matched within 1 unit in-game.
#define NEO_HULL_TOLERANCE_SCALE 1.078125

#define NEO_RECON_MODEL_SCALE ((NEO_RECON_PLAYERMODEL_HEIGHT / HL2DM_DEFAULT_PLAYERMODEL_HEIGHT) * NEO_HULL_TOLERANCE_SCALE)
#define NEO_ASSAULT_MODEL_SCALE ((NEO_ASSAULT_PLAYERMODEL_HEIGHT / HL2DM_DEFAULT_PLAYERMODEL_HEIGHT) * NEO_HULL_TOLERANCE_SCALE)
#define NEO_SUPPORT_MODEL_SCALE ((NEO_SUPPORT_PLAYERMODEL_HEIGHT / HL2DM_DEFAULT_PLAYERMODEL_HEIGHT) * NEO_HULL_TOLERANCE_SCALE)

#define NEO_RECON_DAMAGE_MODIFIER 1.2f
#define NEO_ASSAULT_DAMAGE_MODIFIER 1.0f
#define NEO_SUPPORT_DAMAGE_MODIFIER 0.56f

#define NEO_ANIMSTATE_LEGANIM_TYPE LegAnimType_t::LEGANIM_9WAY
#define NEO_ANIMSTATE_USES_AIMSEQUENCES true
#define NEO_ANIMSTATE_MAX_BODY_YAW_DEGREES 90.0f

enum NeoSkin {
	NEO_SKIN_FIRST = 0,
	NEO_SKIN_SECOND,
	NEO_SKIN_THIRD,

	NEO_SKIN_ENUM_COUNT
};

enum NeoClass {
	NEO_CLASS_RECON = 0,
	NEO_CLASS_ASSAULT,
	NEO_CLASS_SUPPORT,

	// NOTENOTE: VIP *must* be last, because we are
	// using array offsets for recon/assault/support
	NEO_CLASS_VIP,

	NEO_CLASS_ENUM_COUNT
};

// Implemented by CNEOPlayer::m_fNeoFlags.
// Rolling our own because Source FL_ flags already reserve all 32 bits,
// and extending the type would require a larger refactor.
#define NEO_FL_FREEZETIME (1 << 1) // Freeze player movement, but allow looking around.

#if defined(CLIENT_DLL) && !defined(CNEOBaseCombatWeapon)
#define CNEOBaseCombatWeapon C_NEOBaseCombatWeapon
#endif

#define COLOR_JINRAI COLOR_NEO_GREEN
#define COLOR_NSF COLOR_NEO_BLUE
#define COLOR_SPEC COLOR_NEO_ORANGE

#define COLOR_NEO_BLUE Color(181, 216, 248, 255)
#define COLOR_NEO_GREEN Color(192, 244, 196, 255)
#define COLOR_NEO_ORANGE Color(243, 190, 52, 255)
#define COLOR_NEO_WHITE Color(218, 217, 213, 255)

class CNEO_Player;
class CNEOBaseCombatWeapon;
enum PlayerAnimEvent_t : uint;

extern bool IsThereRoomForLeanSlide(CNEO_Player *player,
	const Vector &targetViewOffset, bool &outStartInSolid);

// Is the player allowed to aim zoom with a weapon of this type?
bool IsAllowedToZoom(CNEOBaseCombatWeapon *pWep);

extern ConVar neo_recon_superjump_intensity;

//ConVar sv_neo_resupply_anywhere("sv_neo_resupply_anywhere", "0", FCVAR_CHEAT | FCVAR_REPLICATED);

inline const char *GetRankName(int xp)
{
	if (xp < 0)
	{
		return "Rankless Dog";
	}
	else if (xp < 4)
	{
		return "Private";
	}
	else if (xp < 10)
	{
		return "Corporal";
	}
	else if (xp < 20)
	{
		return "Sergeant";
	}
	else
	{
		return "Lieutenant";
	}
}

CBaseCombatWeapon* GetNeoWepWithBits(const CNEO_Player* player, const NEO_WEP_BITS_UNDERLYING_TYPE& neoWepBits);

// Temporary helper for converting between these. Should refactor this to use the same structure for both.
// Returns true on success. If returns false, the out value will not be set.
bool PlayerAnimToPlayerAnimEvent(const PLAYER_ANIM playerAnim, PlayerAnimEvent_t& outAnimEvent);

#endif // NEO_PLAYER_SHARED_H